// _____________________________________________________________________________
// |                                                                           |
// | DMC-1 TinyGPU, demo SOC with a RISC-V processor (ice-v dual)              |
// |                                                                           |
// | @sylefeb 2020-12-02                                                       |
// |___________________________________________________________________________|
// |                                                                           |
// |  License: CERN-OHL-S                                                      |
// |     A copy of the license full text is included in                        |
// |     the distribution, please refer to it for details.                     |
// |___________________________________________________________________________|

// Below we can choose between spiflash 2x or 4x
// Using 4x would allow faster texture accesses, but is not stable/working yet
// Using 2x works and allows (some) overclocking
$$spi4x = nil

$$if not MCH2022 then
$$if spi4x then
  $$master_freq = 100
  $$uart_in_clock_freq_mhz = master_freq//4
  $include('../../common/spiflash4x.si')
  import('../../common/ice40_half_quarter_clock.v')
$$else
  $$master_freq = 50
  $$uart_in_clock_freq_mhz = master_freq//2
  $include('../../common/spiflash2x.si')
  import('../../common/ice40_half_clock.v')
$$end
$$else
  $$master_freq = 50
  $$uart_in_clock_freq_mhz = master_freq//2
  $include('../../common/qpsram2x.si')
  import('../../common/ice40_half_clock.v')
$$end

$include('../../common/uart.si')

$$if SIMULATION then
$$verbose    = nil
$$end

// A small BRAM contains the bootloader (firmware/boot.c)
$$bram_depth         = 9
// Using 320x240 screen
$$ST7789             = 1
// Use all 128KB of SPRAM
$$SPRAM_128K         = 1

$$if ICE40 then
import('../../common/icebrkr_$master_freq$.v')
import('../../common/ice40_spram.v')
$$end

$$if SIMULATION then
$include('../../common/simulation_spram.si')
$$end

$include('../../GPUs/dmc-1/dmc-1.si')

// configuration for the ice-v-dual
$$ICEV_MULDIV        = 1
$$ICEV_FAST_SHIFT    = 1
$$ICEV_USERDATA      = 1
$$ICEV_ALU_LATCH     = 1
$$Boot               = (1<<17)>>2
$$addrW              = 17
//_                    ^^ 2^17 (128K) + 1 bit for BRAM + 1 bit for mapping
//_                    divided by 4 as we address 32 bits words
group bram_port_io {
  uint$addrW$ addr(0),
  uint4       wenable(0),
  uint32      rdata(0),
  uint32      wdata(0),
}

// pre-compilation script, embeds code within string for BRAM and outputs sdcard image
$$sdcard_image_pad_size = 0
$$dofile('../../../software/compile/ice40/pre_include_asm.lua')
$$code_size_bytes = init_data_bytes

$include('../../common/ice-v-dual.si')
$$clean_reset_width = 4
$include('../../common/clean_reset.si')
$include('bram_spram_32bits.si')

// --------------------------------------------------
// PLL for simulation
// --------------------------------------------------

$$if SIMULATION then
algorithm pll(
  output! uint1 clock4x,
  output  uint1 clock2x,
  output  uint1 clock1x,
) <autorun> {
  uint2 counter(0);
  always {
    clock4x =  clock;
    clock2x =  counter[0,1]; // x2 slower
    clock1x = ~counter[1,1]; // x4 slower
    counter =  counter + 1;
  }
}
$$end

// --------------------------------------------------
// Design main
// --------------------------------------------------

algorithm main(
  output uint$NUM_LEDS$ leds,
$$if BUTTONS then
  input  uint$NUM_BTNS$ btns,
$$end
$$if UART then
  output uint1 uart_tx,
  input  uint1 uart_rx,
$$end
$$if QSPIFLASH then
  output  uint1 sf_clk,
  output  uint1 sf_csn,
  inout   uint1 sf_io0,
  inout   uint1 sf_io1,
  inout   uint1 sf_io2,
  inout   uint1 sf_io3,
$$end
$$if PSRAM then
  output  uint1 ram_clk,
  output  uint1 ram_csn,
  inout   uint1 ram_io0,
  inout   uint1 ram_io1,
  inout   uint1 ram_io2,
  inout   uint1 ram_io3,
$$end
$$if OLED then
  output  uint1 oled_clk,
  output  uint1 oled_mosi,
  output  uint1 oled_dc,
  output  uint1 oled_resn,
  output  uint1 oled_csn,
$$if VERILATOR then
  output uint2  spiscreen_driver(2/*ST7789*/),
  output uint10 spiscreen_width (320),
  output uint10 spiscreen_height(240),
$$end
$$end
$$if LCD then
  output uint8 lcd_d,
  output uint1 lcd_rs,
  output uint1 lcd_wr_n,
  output uint1 lcd_cs_n(0),
  output uint1 lcd_rst_n(1),
  input  uint1 lcd_mode,
  input  uint1 lcd_fmark,
$$end
)
$$if ICE40 then
<@clock1x,!rst1x> {

$$if spi4x then
  uint1 clock4x = uninitialized;
  pll pllgen(
    clock_in  <: clock,
    clock_out :> clock4x,
  );
  uint1 clock1x = uninitialized;
  uint1 clock2x = uninitialized;
  ice40_half_quarter_clock _(
    clock_in  <: clock4x,
    clock_h   :> clock2x,
    clock_q   :> clock1x,
  );
$$else
  uint1 clock2x = uninitialized;
  pll pllgen(
    clock_in  <: clock,
    clock_out :> clock2x,
  );
  uint1 clock1x = uninitialized;
  ice40_half_clock _(
    clock_in  <: clock2x,
    clock_out :> clock1x
  );
$$end
  uint1 rst1x = uninitialized;
  clean_reset r1x<@clock1x,!reset>(
    out :> rst1x
  );
  uint1 rst2x = uninitialized;
  clean_reset r2x<@clock2x,!reset>(
    out :> rst2x
  );
$$elseif SIMULATION then
<@clock1x> {
  uint1 clock1x = uninitialized;
  uint1 clock2x = uninitialized;
  uint1 clock4x = uninitialized;
  pll clkgen<@clock,!reset>(
    clock1x :> clock1x,
    clock2x :> clock2x,
    clock4x :> clock4x
  );
  uint1 rst1x <: reset;
  uint1 rst2x <: reset;
$$else
{
$$end

  // ==============================
  // cpu
  bram_port_io mem;

  bram_spram_32bits bram_ram(
    pram               <:> mem
  );

  uint32 user_data(0);
  rv32i_cpu cpu(
    user_data        <:: user_data,
    mem              <:> mem,
  );

  // ==============================
  // GPU
  spiflash_io      sf_io;
  view             vw;
  tinygpu gpu<reginputs>(sf <:>  sf_io,
                         vw <::> vw);

  // ==============================
  // screen display
  uint1 screen_send(0);
  uint1 screen_send_dc(0);
  uint8 screen_send_byte(0);
  uint1 screen_send_reg(0);
  uint1 screen_send_dc_reg(0);
  uint8 screen_send_byte_reg(0);
  screen_buffer display_buffer<reginputs>(
    send      :> screen_send_reg,
    send_dc   :> screen_send_dc_reg,
    send_byte :> screen_send_byte_reg,
  );

$$if MCH2022 then
  parallel_screen display(
    start           <:: screen_send,
    data_or_command <:: screen_send_dc,
    byte            <:: screen_send_byte,
    screen_d         :> lcd_d,
    screen_dc        :> lcd_rs,
    screen_wrn       :> lcd_wr_n
  );
$$else -- not MCH2022
  uint1 o_mosi(0);
  uint1 o_clk(0);
  uint1 o_dc(0);
  uint1 o_resn(0);
  spi_screen display<@clock2x,!rst2x> (
    start           <:: screen_send,
    data_or_command <:: screen_send_dc,
    byte            <:: screen_send_byte,
$$if VERILATOR then
    screen_mosi      :> oled_mosi,
    screen_clk       :> oled_clk,
    screen_dc        :> oled_dc,
$$else
    screen_mosi      :> o_mosi,
    screen_clk       :> o_clk,
    screen_dc        :> o_dc,
$$end
  );
$$if not SIMULATION then
   sb_io sbio1( clock <: clock2x, out  <: o_clk,  pin  :> oled_clk);
   sb_io sbio0( clock <: clock2x, out  <: o_mosi, pin  :> oled_mosi);
   sb_io sbio2( clock <: clock2x, out  <: o_dc,   pin  :> oled_dc);
   sb_io sbio3( clock <: clock1x, out  <: o_resn, pin  :> oled_resn);
$$end
$$end

  // ==============================
  // texture memory
$$if MCH2022 then
    qpsram_ram sf<@clock2x,!rst2x,reginputs> (
      ram_clk  :> ram_clk,  ram_csn :>  ram_csn,
      ram_io0 <:> ram_io0,  ram_io1 <:> ram_io1,
      ram_io2 <:> ram_io2,  ram_io3 <:> ram_io3,
    );
$$else -- not MCH2022
  $$if spi4x then
    spiflash_rom sf(
      clkspi <: clock4x,
  $$else
    spiflash_rom sf<@clock2x,!rst2x,reginputs> (
  $$end
      sf_clk  :> sf_clk,    sf_csn  :> sf_csn,
      sf_io0 <:> sf_io0,    sf_io1 <:> sf_io1,
      sf_io2 <:> sf_io2,    sf_io3 <:> sf_io3,
    );
$$end

$$if reg_sf_cpu then
  uint8 sf_reg_rdata(0);
  uint1 sf_reg_busy(1);
$$end
$$if SIMULATION then
  // for simulation, create dummy vars
  uint1 sf_csn(1); uint1 sf_clk(0); uint1 sf_io0(0);
  uint1 sf_io1(0); uint1 sf_io2(0); uint1 sf_io3(0);
$$end

  // ==============================
  // UART
  uart_out uo;
$$if UART then
  uart_sender usend<reginputs>(
    io      <:> uo,
    uart_tx :>  uart_tx
  );
$$end

$$if SIMULATION then
  uint32 iter(0);
  uint32 last_iter(0);
$$end

  sameas(mem.addr)    prev_mem_addr(0);
  sameas(mem.wenable) prev_mem_wenable(0);
  sameas(mem.wdata)   prev_mem_wdata(0);

  // ==============================
  // main 'loop'

  always {

    user_data[0,24] = {
                      gpu.pickedh,
$$if reg_sf_cpu then
                      sf_reg_rdata,
$$else
                      sf.rdata,
$$end
$$if BUTTONS then
                      btns[0,3],
$$else
                      3b0,
$$end
                      1b0,
                      1b0,
                      gpu.fifo_empty,
$$if reg_sf_cpu then
                      sf_reg_busy,
$$else
                      sf.busy,
$$end
                      ~gpu.fifo_full
                      };

    sf.in_ready    = sf_io.in_ready;
    sf.addr        = sf_io.addr;
$$if reg_sf_cpu then
    sf_io.data     = sf_reg_rdata;
    sf_io.busy     = sf_reg_busy;
    sf_reg_rdata   = sf.rdata;
    sf_reg_busy    = sf.busy | sf_io.in_ready;
$$else
    sf_io.data     = sf.rdata;
    sf_io.busy     = sf.busy;
$$end

    gpu           .in_ready = 0;
    display_buffer.in_ready = gpu.screen_send;
    display_buffer.in_data  = gpu.screen_send
                            ? gpu.screen_data : prev_mem_wdata[0,17];

    uo.data_in_ready = 0;

$$if MCH2022 then
    lcd_cs_n  = 0;
    lcd_rst_n = 1;
$$end

    // memory mapping
    if ((prev_mem_wenable != 0) & prev_mem_addr[16,1]) {
      switch (prev_mem_addr[2,4]) {
        case 4b1000: {
          vw.view_z  = prev_mem_wdata[ 0,16];
        }
        case 4b0100: {
          // UART
          uo.data_in       = prev_mem_wdata[ 0,8];
          uo.data_in_ready = ~uo.busy;
$$if SIMULATION then
          __write("%c",prev_mem_wdata[ 0,8]);
$$end
        }
        case 4b0010: {
          switch (prev_mem_addr[0,2]) {
            case 2b00: {
$$if SIMULATION then
              __display("(cycle %d) LEDs = %d | %d [elapsed %d]",iter,
                prev_mem_wdata[0,32],__signed( prev_mem_wdata),iter-last_iter);
              last_iter = iter;
$$end
              leds = prev_mem_wdata[0,8];
            }
            case 2b01: {
              // SPIscreen
              display_buffer.in_ready = 1;
            }
            case 2b11: {
              // SPIscreen reset
$$if VERILATOR then
              oled_resn = ~ prev_mem_wdata[0,1];
$$elseif not MCH2022 then
              o_resn    = ~ prev_mem_wdata[0,1];
$$end
            }
            case 2b10: {
              // texture memory
              sf.addr     = prev_mem_wdata[0,24];
              sf.in_ready = 1; // NOTE: we assume there cannot be collisions
                               // with the texture sampler ; CPU should not
                               // drive the texture while draw calls are pending
            }
            default: { }
          }
        }
        case 4b0001: {
          if (prev_mem_addr[0,1]) {
            // received first half
            gpu.in_command[32,32] = prev_mem_wdata[0,32];
          } else {
            // received tex1
            uint1  param   <:: prev_mem_wdata[30,2] == 2b11;
            uint8  start   <:: prev_mem_wdata[10,8];
            uint8  end     <:: prev_mem_wdata[18,8];
            uint1  empty   <:: start > end;
            uint1  eoc     <:: prev_mem_wdata[0,1];
            // send segment to drawer
            gpu.in_command[0,32] = prev_mem_wdata[0,32];
            gpu.in_ready         = ~empty | eoc | param; // not null or eoc tag
$$if SIMULATION then
            if ((~empty | eoc) & ~param) {
              if (eoc) {
                // __display("[%d] draw EOC",iter);
              } else {
                //__display("[%d] span %d -> %d",iter,start,end);
              }
            }
            if (gpu.in_ready) {
              //__display("[%d] draw call RECORD",iter);
            }
$$end
          }
        }
        default: { }
      }
    }

    // we can take one cycle to refresh the mappings, no need to pressure fmax
    prev_mem_addr    = mem.addr;
    prev_mem_wenable = mem.wenable;
    prev_mem_wdata   = mem.wdata;
    // we register the oled inputs to relax fmax
    screen_send      = screen_send_reg;
    screen_send_dc   = screen_send_dc_reg;
    screen_send_byte = screen_send_byte_reg;

$$if SIMULATION then
    // if (iter == 20000000) { __finish(); }
    iter = iter + 1;
$$end

  }
}

// -------------------------
