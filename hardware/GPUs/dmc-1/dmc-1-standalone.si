// _____________________________________________________________________________
// |                                                                           |
// | DMC-1 TinyGPU, standalone version                                         |
// |                                                                           |
// |                                                                           |
// | @sylefeb 2022-07-10                                                       |
// |___________________________________________________________________________|
// |                                                                           |
// |  License: CERN-OHL-S                                                      |
// |     A copy of the license full text is included in                        |
// |     the distribution, please refer to it for details.                     |
// |___________________________________________________________________________|

$include("dmc-1.si")

$$if MCH2022 or (SIMULATION and SIMUL_QPSRAM) or BROT then
  $include('../../common/qpsram2x.si')
$$else
  $include('../../common/spiflash2x.si')
$$end

// ___________________________________________________________________________
// A helper unit that converts the data available 2x pulse it into a
// high signal (allows to cross 2x => 1x since once data starts coming,
// it comes at every 1x cycle

unit adapterDataAvailable(
  input   uint1 valid,
  input   uint1 data_avail_pulse,
  output! uint1 data_avail_high
)
{
  always {
    data_avail_high = ~valid ? 0 : (data_avail_high | data_avail_pulse);
  }
}

// ___________________________________________________________________________
// The standalone version includes the memory controller

unit DMC_1_gpu_standalone(
  // command interface
  input   uint1   in_next, // pulse
  output  uint1   ready,
  input   uint64  command,
  // screen interface
  input   uint1   screen_ready,
  output! uint1   screen_valid(0),
  output! uint16  screen_data,
  // texture memory interface
  input   uint1   clock2x,
  output  uint1   ram_clk,
  output  uint1   ram_csn,
  inout   uint1   ram_io0,
  inout   uint1   ram_io1,
  inout   uint1   ram_io2,
  inout   uint1   ram_io3,
  // direct memory interface (assumes GPU not busy!)
  input   uint1   ram_write,
  input   uint24  ram_addr,
  input   uint64  ram_wdata, // {32b<data>,32b0} if 32 bits (see mask next)
  input   uint2   ram_wmask, // 01 if 32 bits, 11 if 64 bits
  input   uint1   ram_read,
  output  uint8   ram_rdata,
  output  uint1   ram_next_byte,
) {

  // ==============================
  // texture memory
$$if MCH2022 or (SIMULATION and SIMUL_QPSRAM) or BROT then
  qpsram_ram txm<@clock2x,reginputs> (
    ram_clk  :> ram_clk,  ram_csn :>  ram_csn,
    ram_io0 <:> ram_io0,  ram_io1 <:> ram_io1,
    ram_io2 <:> ram_io2,  ram_io3 <:> ram_io3,
  );
$$else
  spiflash_rom_core txm<@clock2x,reginputs> (
    sf_clk  :> ram_clk,   sf_csn  :> ram_csn,
    sf_io0 <:> ram_io0,   sf_io1 <:> ram_io1,
    sf_io2 <:> ram_io2,   sf_io3 <:> ram_io3,
  );
$$end
  // adapts the data available pulse across clock domains
  adapterDataAvailable _<@clock2x>(
    valid            <: txm.in_ready,
$$if MCH2022 or (SIMULATION and SIMUL_QPSRAM) or BROT then
    data_avail_pulse <: txm.data_next,
$$else
    data_avail_pulse <: txm.rdata_available, // FIXME: update all to new controller
$$end
    data_avail_high  :> txm_io.data_available
  );

  // ==============================
  // GPU
  texmem_io     txm_io;
  DMC_1_gpu gpu(txm <:> txm_io,
                <:auto:>
               );

  uint64 wdata(0);

  always_before {
$$if MCH2022 or (SIMULATION and SIMUL_QPSRAM) or BROT then
    txm.wenable  = 0;
    txm.in_ready = ram_read | txm_io.in_ready;
    txm.addr     = ram_read ? ram_addr : txm_io.addr;
$$end
  }

  algorithm <autorun> {
    while (1) {
      if (ram_write) {
        uint24 waddr = ram_addr;
        // setup write
        txm.wenable  = 1;
        txm.addr     = waddr;
        txm.in_ready = 1;
        wdata        = ram_wdata;
        uint4 n      = 0;
        uint2 mask   = ram_wmask;
        while (mask[1,1] ? ~n[3,1] : ~n[2,1]) {
          txm.wenable  = 1;
          txm.addr     = waddr;
          txm.in_ready = 1;
          if (txm.wstream_1x) {
            // ^^^^^^^^^^^ used directly as inputs are registered
            txm.wdata = wdata[56,8];
            wdata     = wdata << 8;
            // __display("[GPU] writing %x @%x",txm.wdata,waddr + n);
            n         = n + 1;
          }
        }
      }
    }
  }

  always_after {
    // texture memory interface
    txm_io.data  = txm.rdata;
    txm_io.busy  = txm.busy;
$$if MCH2022 or (SIMULATION and SIMUL_QPSRAM) or BROT then
    txm.init     = 0;
$$end
    // ram read
    ram_rdata     = txm.rdata;
    ram_next_byte = txm_io.data_available;
  }

}